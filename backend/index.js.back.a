// Discord OAuth用
async function getDiscordToken(code, redirectUri, clientId, clientSecret) {
  const params = new URLSearchParams({
    client_id: clientId,
    client_secret: clientSecret,
    grant_type: 'authorization_code',
    code,
    redirect_uri: redirectUri,
    scope: 'identify email',
  });
  const res = await fetch('https://discord.com/api/oauth2/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params.toString(),
  });
  return res.json();
}

async function getDiscordUser(accessToken) {
  const res = await fetch('https://discord.com/api/users/@me', {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  return res.json();
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // CORS設定
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Internal-Secret, X-Service-Token',
    };

    // OPTIONS リクエスト（プリフライト）の処理
    if (request.method === 'OPTIONS') {
      return new Response(null, { status: 200, headers: corsHeaders });
    }

    // Service Token 認証
    try {
        const SERVICE_TOKEN = env.SERVICE_TOKEN || '';
        const isApiPath = url.pathname.startsWith('/api');
        const skipTokenPaths = ['/api/test', '/api/discord/callback', '/api/dashboard'];
        const requiresAuth = isApiPath && !skipTokenPaths.some(path => url.pathname.startsWith(path));
        
        if (requiresAuth && SERVICE_TOKEN) {
            const authHeader = request.headers.get('authorization') || '';
            const serviceTokenHeader = request.headers.get('x-service-token') || '';
            
            let token = '';
            if (authHeader && authHeader.toLowerCase().startsWith('bearer ')) {
                token = authHeader.slice(7).trim();
            } else if (serviceTokenHeader) {
                token = serviceTokenHeader.trim();
            }
            
            if (!token || token !== SERVICE_TOKEN) {
                console.warn(`[Auth] Unauthorized access attempt to ${url.pathname}`);
                return new Response(JSON.stringify({ error: 'Unauthorized' }), { 
                    status: 401, 
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
        }

    // プロキシ処理：画像関連のパスをバックエンドにプロキシ
    if (url.pathname.startsWith('/images/')) {
        console.log(`[PROXY] Proxying image request: ${url.pathname}`);
        const targetURL = 'https://api.rectbot.tech' + url.pathname + url.search;
        
        const resp = await fetch(targetURL, {
            method: request.method,
            headers: request.headers,
            body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,
        });
        
        const respHeaders = Array.from(resp.headers.entries()).filter(([key]) => 
            !['content-encoding', 'content-length', 'transfer-encoding'].includes(key.toLowerCase())
        );
        
        const buf = await resp.arrayBuffer();
        return new Response(buf, { status: resp.status, headers: { ...corsHeaders, ...Object.fromEntries(respHeaders) } });
    }

    // --- Discord bot recruitment data push endpoint ---
    if (url.pathname === '/api/recruitment/push' && request.method === 'POST') {
        try {
            // セキュリティ検証
            const authHeader = request.headers.get('authorization') || '';
            const userAgent = request.headers.get('user-agent') || '';
            const clientIP = request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || 'unknown';
            
            // 1. 認証トークン検証
            const SERVICE_TOKEN = env.SERVICE_TOKEN || '';
            if (!SERVICE_TOKEN) {
                return new Response(JSON.stringify({ error: 'service_unavailable' }), { 
                    status: 503, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            let token = '';
            if (authHeader && authHeader.toLowerCase().startsWith('bearer ')) {
                token = authHeader.slice(7).trim();
            }
            
            if (!token || token !== SERVICE_TOKEN) {
                console.warn(`[security] Unauthorized push attempt from IP: ${clientIP}, UA: ${userAgent}`);
                return new Response(JSON.stringify({ error: 'unauthorized' }), { 
                    status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            // 2. User-Agent検証（Discord botからの正当なリクエストか）
            if (!userAgent.includes('node') && !userAgent.includes('discord')) {
                console.warn(`[security] Suspicious User-Agent from IP: ${clientIP}, UA: ${userAgent}`);
                return new Response(JSON.stringify({ error: 'forbidden' }), { 
                    status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            console.log(`[worker][recruitment-push] Request received from IP: ${clientIP}`);
            
            const data = await request.json();
            console.log(`[worker][recruitment-push] Received data:`, JSON.stringify(data, null, 2));
            
            // 4. データ検証強化
            if (!data.recruitId || !data.guildId) {
                console.error(`[worker][recruitment-push] Missing required fields. recruitId: ${data.recruitId}, guildId: ${data.guildId}`);
                return new Response(JSON.stringify({ 
                    error: 'invalid_data', 
                    detail: 'recruitId and guildId are required' 
                }), { 
                    status: 400, 
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // 5. 入力サニタイゼーション
            const sanitizedData = {
                recruitId: String(data.recruitId).slice(0, 50),
                guildId: String(data.guildId).slice(0, 20),
                channelId: String(data.channelId || '').slice(0, 20),
                message_id: String(data.message_id || '').slice(0, 20),
                status: String(data.status || 'recruiting').slice(0, 20),
                start_time: data.start_time || new Date().toISOString()
            };
            
            console.log(`[worker][recruitment-push] Authorized request from IP: ${clientIP}, recruitId: ${sanitizedData.recruitId}`);
            
            return new Response(JSON.stringify({ 
                success: true, 
                recruitId: sanitizedData.recruitId,
                guildId: sanitizedData.guildId,
                message: 'Data received successfully'
            }), { 
                status: 200, 
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
            
        } catch (err) {
            console.error('[worker][recruitment-push] Error:', err);
            return new Response(JSON.stringify({ 
                error: 'internal_error'
            }), { 
                status: 500, 
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
    }

    // 募集データAPI - VPS Expressにプロキシ
    if (url.pathname === "/api/recruitment") {
      if (request.method === "POST") {
        try {
          console.log('[POST] Proxying recruitment save to VPS Express');
          
          // VPS ExpressサーバーのURL構築
          const vpsUrl = 'https://api.rectbot.tech/api/recruitment';
          
          // リクエストボディを取得
          const data = await request.json();
          
          // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
          const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
          };
          
          const vpsResponse = await fetch(vpsUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(data)
          });
          
          const responseText = await vpsResponse.text();
          let responseBody;
          try {
            responseBody = JSON.parse(responseText);
          } catch (e) {
            responseBody = { message: responseText };
          }
          
          console.log(`[POST] VPS Express response status: ${vpsResponse.status}`);
          
          return new Response(JSON.stringify(responseBody), {
            status: vpsResponse.status,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
          
        } catch (error) {
          console.error('[POST] Error proxying to VPS Express:', error);
          return new Response(JSON.stringify({ 
            error: "Internal server error",
            details: error.message 
          }), { 
            status: 500, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
      }
      
      if (request.method === "GET") {
        try {
          console.log('[GET] Proxying recruitment list to VPS Express');
          
          // VPS ExpressサーバーのURL構築
          const vpsUrl = 'https://api.rectbot.tech/api/recruitment';
          
          // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
          const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
          };
          
          const vpsResponse = await fetch(vpsUrl, {
            method: 'GET',
            headers
          });
          
          const responseText = await vpsResponse.text();
          let responseBody;
          try {
            responseBody = JSON.parse(responseText);
          } catch (e) {
            responseBody = { message: responseText };
          }
          
          console.log(`[GET] VPS Express response status: ${vpsResponse.status}`);
          
          return new Response(JSON.stringify(responseBody), {
            status: vpsResponse.status,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
          
        } catch (error) {
          console.error('[GET] Error proxying to VPS Express:', error);
          return new Response(JSON.stringify({ 
            error: "Internal server error",
            details: error.message 
          }), { 
            status: 500, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
      }
      
      return new Response("Method Not Allowed", { 
        status: 405, 
        headers: corsHeaders 
      });
    }

    // 募集データのステータス更新API（特定のメッセージID）- VPS Expressにプロキシ
    if (url.pathname.startsWith("/api/recruitment/") && request.method === "PATCH") {
      const messageId = url.pathname.split("/api/recruitment/")[1];
      if (!messageId) {
        return new Response(JSON.stringify({ error: "Message ID required" }), { 
          status: 400, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      
      try {
        console.log(`[PATCH] Proxying recruitment update to VPS Express: ${messageId}`);
        
        // VPS ExpressサーバーのURL構築
        const vpsUrl = `https://api.rectbot.tech/api/recruitment/${messageId}`;
        
        // リクエストボディを取得
        const updateData = await request.json();
        
        // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
        const headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
        };
        
        const vpsResponse = await fetch(vpsUrl, {
          method: 'PATCH',
          headers,
          body: JSON.stringify(updateData)
        });
        
        const responseText = await vpsResponse.text();
        let responseBody;
        try {
          responseBody = JSON.parse(responseText);
        } catch (e) {
          responseBody = { message: responseText };
        }
        
        console.log(`[PATCH] VPS Express response status: ${vpsResponse.status}`);
        
        return new Response(JSON.stringify(responseBody), {
          status: vpsResponse.status,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[PATCH] Error proxying to VPS Express:', error);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message 
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // 募集データ削除API（特定のメッセージID）- VPS Expressにプロキシ
    if (url.pathname.startsWith("/api/recruitment/") && request.method === "DELETE") {
      const messageId = url.pathname.split("/api/recruitment/")[1];
      if (!messageId) {
        return new Response(JSON.stringify({ error: "Message ID required" }), { 
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }

      try {
        console.log(`[DELETE] Proxying recruitment deletion to VPS Express: ${messageId}`);
        
        // VPS ExpressサーバーのURL構築
        const vpsUrl = `https://api.rectbot.tech/api/recruitment/${messageId}`;
        
        // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
        const headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
        };
        
        const vpsResponse = await fetch(vpsUrl, {
          method: 'DELETE',
          headers
        });
        
        const responseText = await vpsResponse.text();
        let responseBody;
        try {
          responseBody = JSON.parse(responseText);
        } catch (e) {
          responseBody = { message: responseText };
        }
        
        console.log(`[DELETE] VPS Express response status: ${vpsResponse.status}`);
        
        return new Response(JSON.stringify(responseBody), {
          status: vpsResponse.status,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[DELETE] Error proxying to VPS Express:', error);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message 
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // ギルド設定最終保存API
    if (url.pathname === "/api/guild-settings/finalize" && request.method === "POST") {
      try {
        // Accept payload that may contain guildId and setting fields
        const payload = await request.json();
        const guildId = payload && payload.guildId;
        const incomingSettings = { ...payload };
        delete incomingSettings.guildId;

        if (!guildId) {
          return new Response(JSON.stringify({ error: "Guild ID required" }), { 
            status: 400, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }

        console.log(`[finalize] Starting finalization for guild: ${guildId}`);
        console.log('[finalize] Incoming settings:', incomingSettings);

        // Map incoming settings to Supabase format
        const supabaseData = {
          guild_id: guildId,
          recruit_channel_id: incomingSettings.recruit_channel || null,
          notification_role_id: incomingSettings.notification_role || null,
          default_title: incomingSettings.defaultTitle || "参加者募集",
          default_color: incomingSettings.defaultColor || "#00FFFF",
          update_channel_id: incomingSettings.update_channel || null,
          updated_at: new Date().toISOString()
        };
        
        console.log(`[finalize] Supabase data to save:`, supabaseData);
        
        // まず既存レコードがあるか確認
        const existingRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!existingRes.ok) {
          throw new Error(`Failed to check existing settings: ${existingRes.status} - ${await existingRes.text()}`);
        }
        
        const existingData = await existingRes.json();
        console.log(`[finalize] Existing guild settings:`, existingData);
        
        let supaRes;
        if (existingData && existingData.length > 0) {
          // 更新操作
          console.log(`[finalize] Updating existing guild settings for ${guildId}`);
          const patchBody = {
            updated_at: new Date().toISOString()
          };
          
          // Only include fields that are not null/undefined
          if (supabaseData.recruit_channel_id !== null) patchBody.recruit_channel_id = supabaseData.recruit_channel_id;
          if (supabaseData.notification_role_id !== null) patchBody.notification_role_id = supabaseData.notification_role_id;
          if (supabaseData.default_title) patchBody.default_title = supabaseData.default_title;
          if (supabaseData.default_color) patchBody.default_color = supabaseData.default_color;
          if (supabaseData.update_channel_id !== null) patchBody.update_channel_id = supabaseData.update_channel_id;

          supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
            method: 'PATCH',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(patchBody)
          });
        } else {
          // 新規作成
          console.log(`[finalize] Creating new guild settings for ${guildId}`);
          supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings', {
            method: 'POST',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(supabaseData)
          });
        }
        
        if (!supaRes.ok) {
          const errorText = await supaRes.text();
          console.error(`[finalize] Supabase operation failed:`);
          console.error(`[finalize] Status: ${supaRes.status}`);
          console.error(`[finalize] Status Text: ${supaRes.statusText}`);
          console.error(`[finalize] Response Body: ${errorText}`);
          throw new Error(`Supabase save failed: ${supaRes.status} - ${errorText}`);
        }
        
        console.log(`[finalize] Guild settings saved successfully for guild ${guildId}`);
        
        return new Response(JSON.stringify({ 
          ok: true, 
          message: "Settings saved successfully"
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[finalize] Guild settings finalize error:', error);
        console.error('[finalize] Error stack:', error.stack);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message,
          timestamp: new Date().toISOString()
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // デバッグ用テストエンドポイント
    if (url.pathname === '/api/test' && request.method === 'GET') {
      return new Response(JSON.stringify({ 
        message: 'Backend is working!', 
        timestamp: new Date().toISOString(),
        path: url.pathname,
        method: request.method
      }), { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // すべてのルートにマッチしなかった場合の404レスポンス
    return new Response("Not Found", { 
      status: 404, 
      headers: corsHeaders 
    });

    } catch (error) {
      console.error('Request processing error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal server error',
        details: error.message 
      }), { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
}

    // プロキシ処理：画像関連のパスをバックエンドにプロキシ
    if (url.pathname.startsWith('/images/')) {
        console.log(`[PROXY] Proxying image request: ${url.pathname}`);
        const targetURL = 'https://api.rectbot.tech' + url.pathname + url.search;
        
        const resp = await fetch(targetURL, {
            method: request.method,
            headers: request.headers,
            body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,
        });
        
        const respHeaders = Array.from(resp.headers.entries()).filter(([key]) => 
            !['content-encoding', 'content-length', 'transfer-encoding'].includes(key.toLowerCase())
        );
        
        const buf = await resp.arrayBuffer();
        return new Response(buf, { status: resp.status, headers: { ...corsHeaders, ...Object.fromEntries(respHeaders) } });
    }

    // --- Discord bot recruitment data push endpoint ---
    if (url.pathname === '/api/recruitment/push' && request.method === 'POST') {
        try {
            // セキュリティ検証
            const authHeader = request.headers.get('authorization') || '';
            const userAgent = request.headers.get('user-agent') || '';
            const clientIP = request.headers.get('cf-connecting-ip') || request.headers.get('x-forwarded-for') || 'unknown';
            
            // 1. 認証トークン検証
            const SERVICE_TOKEN = env.SERVICE_TOKEN || '';
            if (!SERVICE_TOKEN) {
                return new Response(JSON.stringify({ error: 'service_unavailable' }), { 
                    status: 503, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            let token = '';
            if (authHeader && authHeader.toLowerCase().startsWith('bearer ')) {
                token = authHeader.slice(7).trim();
            }
            
            if (!token || token !== SERVICE_TOKEN) {
                console.warn(`[security] Unauthorized push attempt from IP: ${clientIP}, UA: ${userAgent}`);
                return new Response(JSON.stringify({ error: 'unauthorized' }), { 
                    status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            // 2. User-Agent検証（Discord botからの正当なリクエストか）
            if (!userAgent.includes('node') && !userAgent.includes('discord')) {
                console.warn(`[security] Suspicious User-Agent from IP: ${clientIP}, UA: ${userAgent}`);
                return new Response(JSON.stringify({ error: 'forbidden' }), { 
                    status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
                });
            }
            
            console.log(`[worker][recruitment-push] Request received from IP: ${clientIP}`);
            
            const data = await request.json();
            console.log(`[worker][recruitment-push] Received data:`, JSON.stringify(data, null, 2));
            
            // 4. データ検証強化
            if (!data.recruitId || !data.guildId) {
                console.error(`[worker][recruitment-push] Missing required fields. recruitId: ${data.recruitId}, guildId: ${data.guildId}`);
                return new Response(JSON.stringify({ 
                    error: 'invalid_data', 
                    detail: 'recruitId and guildId are required' 
                }), { 
                    status: 400, 
                    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
                });
            }
            
            // 5. 入力サニタイゼーション
            const sanitizedData = {
                recruitId: String(data.recruitId).slice(0, 50),
                guildId: String(data.guildId).slice(0, 20),
                channelId: String(data.channelId || '').slice(0, 20),
                message_id: String(data.message_id || '').slice(0, 20),
                status: String(data.status || 'recruiting').slice(0, 20),
                start_time: data.start_time || new Date().toISOString()
            };
            
            console.log(`[worker][recruitment-push] Authorized request from IP: ${clientIP}, recruitId: ${sanitizedData.recruitId}`);
            
            return new Response(JSON.stringify({ 
                success: true, 
                recruitId: sanitizedData.recruitId,
                guildId: sanitizedData.guildId,
                message: 'Data received successfully'
            }), { 
                status: 200, 
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
            
        } catch (err) {
            console.error('[worker][recruitment-push] Error:', err);
            return new Response(JSON.stringify({ 
                error: 'internal_error'
            }), { 
                status: 500, 
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            });
        }
    }

    // 募集データAPI - VPS Expressにプロキシ
    if (url.pathname === "/api/recruitment") {
      if (request.method === "POST") {
        try {
          console.log('[POST] Proxying recruitment save to VPS Express');
          
          // VPS ExpressサーバーのURL構築
          const vpsUrl = 'https://api.rectbot.tech/api/recruitment';
          
          // リクエストボディを取得
          const data = await request.json();
          
          // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
          const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
          };
          
          const vpsResponse = await fetch(vpsUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(data)
          });
          
          const responseText = await vpsResponse.text();
          let responseBody;
          try {
            responseBody = JSON.parse(responseText);
          } catch (e) {
            responseBody = { message: responseText };
          }
          
          console.log(`[POST] VPS Express response status: ${vpsResponse.status}`);
          
          return new Response(JSON.stringify(responseBody), {
            status: vpsResponse.status,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
          
        } catch (error) {
          console.error('[POST] Error proxying to VPS Express:', error);
          return new Response(JSON.stringify({ 
            error: "Internal server error",
            details: error.message 
          }), { 
            status: 500, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
      }
      
      if (request.method === "GET") {
        try {
          console.log('[GET] Proxying recruitment list to VPS Express');
          
          // VPS ExpressサーバーのURL構築
          const vpsUrl = 'https://api.rectbot.tech/api/recruitment';
          
          // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
          const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
          };
          
          const vpsResponse = await fetch(vpsUrl, {
            method: 'GET',
            headers
          });
          
          const responseText = await vpsResponse.text();
          let responseBody;
          try {
            responseBody = JSON.parse(responseText);
          } catch (e) {
            responseBody = { message: responseText };
          }
          
          console.log(`[GET] VPS Express response status: ${vpsResponse.status}`);
          
          return new Response(JSON.stringify(responseBody), {
            status: vpsResponse.status,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
          
        } catch (error) {
          console.error('[GET] Error proxying to VPS Express:', error);
          return new Response(JSON.stringify({ 
            error: "Internal server error",
            details: error.message 
          }), { 
            status: 500, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
      }
      
      return new Response("Method Not Allowed", { 
        status: 405, 
        headers: corsHeaders 
      });
    }

    // 募集データのステータス更新API（特定のメッセージID）- VPS Expressにプロキシ
    if (url.pathname.startsWith("/api/recruitment/") && request.method === "PATCH") {
      const messageId = url.pathname.split("/api/recruitment/")[1];
      if (!messageId) {
        return new Response(JSON.stringify({ error: "Message ID required" }), { 
          status: 400, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      
      try {
        console.log(`[PATCH] Proxying recruitment update to VPS Express: ${messageId}`);
        
        // VPS ExpressサーバーのURL構築
        const vpsUrl = `https://api.rectbot.tech/api/recruitment/${messageId}`;
        
        // リクエストボディを取得
        const updateData = await request.json();
        
        // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
        const headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
        };
        
        const vpsResponse = await fetch(vpsUrl, {
          method: 'PATCH',
          headers,
          body: JSON.stringify(updateData)
        });
        
        const responseText = await vpsResponse.text();
        let responseBody;
        try {
          responseBody = JSON.parse(responseText);
        } catch (e) {
          responseBody = { message: responseText };
        }
        
        console.log(`[PATCH] VPS Express response status: ${vpsResponse.status}`);
        
        return new Response(JSON.stringify(responseBody), {
          status: vpsResponse.status,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[PATCH] Error proxying to VPS Express:', error);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message 
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // 募集データ削除API（特定のメッセージID）- VPS Expressにプロキシ
    if (url.pathname.startsWith("/api/recruitment/") && request.method === "DELETE") {
      const messageId = url.pathname.split("/api/recruitment/")[1];
      if (!messageId) {
        return new Response(JSON.stringify({ error: "Message ID required" }), { 
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }

      try {
        console.log(`[DELETE] Proxying recruitment deletion to VPS Express: ${messageId}`);
        
        // VPS ExpressサーバーのURL構築
        const vpsUrl = `https://api.rectbot.tech/api/recruitment/${messageId}`;
        
        // SERVICE_TOKENを使ってVPS Expressサーバーにプロキシ
        const headers = {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${env.SERVICE_TOKEN || ''}`
        };
        
        const vpsResponse = await fetch(vpsUrl, {
          method: 'DELETE',
          headers
        });
        
        const responseText = await vpsResponse.text();
        let responseBody;
        try {
          responseBody = JSON.parse(responseText);
        } catch (e) {
          responseBody = { message: responseText };
        }
        
        console.log(`[DELETE] VPS Express response status: ${vpsResponse.status}`);
        
        return new Response(JSON.stringify(responseBody), {
          status: vpsResponse.status,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[DELETE] Error proxying to VPS Express:', error);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message 
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // ギルド設定最終保存API
    if (url.pathname === "/api/guild-settings/finalize" && request.method === "POST") {
      try {
        // Accept payload that may contain guildId and setting fields
        const payload = await request.json();
        const guildId = payload && payload.guildId;
        const incomingSettings = { ...payload };
        delete incomingSettings.guildId;

        if (!guildId) {
          return new Response(JSON.stringify({ error: "Guild ID required" }), { 
            status: 400, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }

        console.log(`[finalize] Starting finalization for guild: ${guildId}`);
        console.log('[finalize] Incoming settings:', incomingSettings);

        // Map incoming settings to Supabase format
        const supabaseData = {
          guild_id: guildId,
          recruit_channel_id: incomingSettings.recruit_channel || null,
          notification_role_id: incomingSettings.notification_role || null,
          default_title: incomingSettings.defaultTitle || "参加者募集",
          default_color: incomingSettings.defaultColor || "#00FFFF",
          update_channel_id: incomingSettings.update_channel || null,
          updated_at: new Date().toISOString()
        };
        
        console.log(`[finalize] Supabase data to save:`, supabaseData);
        
        // まず既存レコードがあるか確認
        const existingRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!existingRes.ok) {
          throw new Error(`Failed to check existing settings: ${existingRes.status} - ${await existingRes.text()}`);
        }
        
        const existingData = await existingRes.json();
        console.log(`[finalize] Existing guild settings:`, existingData);
        
        let supaRes;
        if (existingData && existingData.length > 0) {
          // 更新操作
          console.log(`[finalize] Updating existing guild settings for ${guildId}`);
          const patchBody = {
            updated_at: new Date().toISOString()
          };
          
          // Only include fields that are not null/undefined
          if (supabaseData.recruit_channel_id !== null) patchBody.recruit_channel_id = supabaseData.recruit_channel_id;
          if (supabaseData.notification_role_id !== null) patchBody.notification_role_id = supabaseData.notification_role_id;
          if (supabaseData.default_title) patchBody.default_title = supabaseData.default_title;
          if (supabaseData.default_color) patchBody.default_color = supabaseData.default_color;
          if (supabaseData.update_channel_id !== null) patchBody.update_channel_id = supabaseData.update_channel_id;

          supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
            method: 'PATCH',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(patchBody)
          });
        } else {
          // 新規作成
          console.log(`[finalize] Creating new guild settings for ${guildId}`);
          supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings', {
            method: 'POST',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(supabaseData)
          });
        }
        
        if (!supaRes.ok) {
          const errorText = await supaRes.text();
          console.error(`[finalize] Supabase operation failed:`);
          console.error(`[finalize] Status: ${supaRes.status}`);
          console.error(`[finalize] Status Text: ${supaRes.statusText}`);
          console.error(`[finalize] Response Body: ${errorText}`);
          throw new Error(`Supabase save failed: ${supaRes.status} - ${errorText}`);
        }
        
        console.log(`[finalize] Guild settings saved successfully for guild ${guildId}`);
        
        return new Response(JSON.stringify({ 
          ok: true, 
          message: "Settings saved successfully"
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[finalize] Guild settings finalize error:', error);
        console.error('[finalize] Error stack:', error.stack);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message,
          timestamp: new Date().toISOString()
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // デバッグ用テストエンドポイント
    if (url.pathname === '/api/test' && request.method === 'GET') {
      return new Response(JSON.stringify({ 
        message: 'Backend is working!', 
        timestamp: new Date().toISOString(),
        path: url.pathname,
        method: request.method
      }), { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // すべてのルートにマッチしなかった場合の404レスポンス
    return new Response("Not Found", { 
      status: 404, 
      headers: corsHeaders 
    });

    } catch (error) {
      console.error('Request processing error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal server error',
        details: error.message 
      }), { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
}
      try {
        const cleanedCount = await cleanupOldRecruitments();
        return new Response(JSON.stringify({ 
          ok: true, 
          cleaned_count: cleanedCount,
          message: `Cleaned up ${cleanedCount} old recruitments`
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } catch (error) {
        console.error("Cleanup error:", error);
        return new Response(JSON.stringify({ error: "Cleanup failed" }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // デバッグ用テストエンドポイント
    if (url.pathname === '/api/test' && request.method === 'GET') {
      return new Response(JSON.stringify({ 
        message: 'Backend is working!', 
        timestamp: new Date().toISOString(),
        path: url.pathname,
        method: request.method
      }), { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Discord OAuthコールバックAPI (POST)
    if (request.method === 'POST' && url.pathname === '/api/discord/callback') {
      const { code } = await request.json();
      if (!code) return new Response(JSON.stringify({ error: 'code missing' }), { status: 400 });
      // 環境変数からDiscord情報取得
      const clientId = env.REACT_APP_DISCORD_CLIENT_ID;
      const clientSecret = env.DISCORD_CLIENT_SECRET;
      const redirectUri = env.REACT_APP_DISCORD_REDIRECT_URI;
      // Discordトークン取得
      const tokenData = await getDiscordToken(code, redirectUri, clientId, clientSecret);
      if (!tokenData.access_token) {
        return new Response(JSON.stringify({ error: 'discord token error', detail: tokenData }), { status: 400 });
      }
      // Discordユーザー情報取得
      const user = await getDiscordUser(tokenData.access_token);
      // Supabase REST APIでユーザー情報保存
      await fetch(env.SUPABASE_URL + '/rest/v1/users', {
        method: 'POST',
        headers: {
          'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
          'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ discord_id: user.id, username: user.username, email: user.email })
      });
      return new Response(JSON.stringify({ user }), { status: 200 });
    }

    // Discord OAuthコールバックAPI (GET) - DiscordからのリダイレクトURL処理
    if (request.method === 'GET' && url.pathname === '/api/discord/callback') {
      const code = url.searchParams.get('code');
      if (!code) {
        return new Response('<!DOCTYPE html><html><body><h1>認証エラー</h1><p>認証コードが見つかりません</p></body></html>', {
          status: 400,
          headers: { 'Content-Type': 'text/html; charset=utf-8' }
        });
      }
      
      try {
        // 環境変数からDiscord情報取得
        const clientId = env.REACT_APP_DISCORD_CLIENT_ID;
        const clientSecret = env.DISCORD_CLIENT_SECRET;
        const redirectUri = env.REACT_APP_DISCORD_REDIRECT_URI;
        
        // Discordトークン取得
        const tokenData = await getDiscordToken(code, redirectUri, clientId, clientSecret);
        if (!tokenData.access_token) {
          return new Response('<!DOCTYPE html><html><body><h1>認証エラー</h1><p>Discordトークンの取得に失敗しました</p></body></html>', {
            status: 400,
            headers: { 'Content-Type': 'text/html; charset=utf-8' }
          });
        }
        
        // Discordユーザー情報取得
        const user = await getDiscordUser(tokenData.access_token);
        
        // Supabase REST APIでユーザー情報保存
        await fetch(env.SUPABASE_URL + '/rest/v1/users', {
          method: 'POST',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ discord_id: user.id, username: user.username, email: user.email })
        });
        
        // ダッシュボードにリダイレクト（ユーザー情報をクエリパラメータで渡す）
        const dashboardUrl = new URL('https://dash.rectbot.tech/');
        dashboardUrl.searchParams.set('auth_success', 'true');
        dashboardUrl.searchParams.set('user_id', user.id);
        dashboardUrl.searchParams.set('username', user.username);
        
        return new Response('', {
          status: 302,
          headers: {
            'Location': dashboardUrl.toString(),
            ...corsHeaders
          }
        });
        
      } catch (error) {
        console.error('Discord OAuth error:', error);
        return new Response('<!DOCTYPE html><html><body><h1>認証エラー</h1><p>認証処理中にエラーが発生しました</p></body></html>', {
          status: 500,
          headers: { 'Content-Type': 'text/html; charset=utf-8' }
        });
      }
    }
  // Stripe Webhook部分はWorkers用に要修正（公式SDKは使えません）
  // if (request.method === 'POST' && url.pathname === '/webhook') {
  //   const sig = request.headers.get('stripe-signature');
  //   const body = await request.text();
  //   // ここでbodyとsigを使って署名検証・イベント処理
  //   // Supabase REST APIでサブスク情報保存
  //   return new Response('Webhook received', { status: 200 });
  // }
    // Supabaseからギルド設定を取得するAPI
    if (url.pathname === '/api/guild-config' && request.method === 'GET') {
      const guildId = url.searchParams.get('guild_id');
      if (!guildId) {
        return new Response(JSON.stringify({ error: 'guild_id missing' }), { status: 400 });
      }
      // Supabase REST APIでguildsテーブルから取得
      const supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guilds?guild_id=eq.${guildId}`, {
        method: 'GET',
        headers: {
          'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
          'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
          'Content-Type': 'application/json',
        },
      });
      const data = await supaRes.json();
      if (!Array.isArray(data) || data.length === 0) {
        return new Response(JSON.stringify({ error: 'not found' }), { status: 404 });
      }
      return new Response(JSON.stringify(data[0]), { status: 200 });
    }
    // 管理者向け: 全ギルドの募集状況・設定をまとめて取得
    if (url.pathname === '/api/admin/guilds' && request.method === 'GET') {
      // Supabaseから全ギルド設定を取得
      const supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guilds', {
        method: 'GET',
        headers: {
          'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
          'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
          'Content-Type': 'application/json',
        },
      });
      const guilds = await supaRes.json();
      // KVから全recruit情報を取得
      const keys = await env.RECRUIT_KV.list();
      const recruitKeys = keys.keys.filter(k => k.name.startsWith('recruit:')).map(k => k.name);
      const recruits = {};
      for (const key of recruitKeys) {
        const val = await env.RECRUIT_KV.get(key);
        if (val) {
          try {
            const data = JSON.parse(val);
            recruits[data.serverId] = data;
          } catch {}
        }
      }
      // guildsとrecruitsをまとめて返す
      return new Response(JSON.stringify({ guilds, recruits }), { status: 200 });
    }

    // ギルド設定最終保存API
    if (url.pathname === "/api/guild-settings/finalize" && request.method === "POST") {
      try {
        // Accept payload that may contain guildId and setting fields
        const payload = await request.json();
        const guildId = payload && payload.guildId;
        const incomingSettings = { ...payload };
        delete incomingSettings.guildId;

        if (!guildId) {
          return new Response(JSON.stringify({ error: "Guild ID required" }), { 
            status: 400, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }

        console.log(`[finalize] Starting finalization for guild: ${guildId}`);
        console.log('[finalize] Incoming settings:', incomingSettings);

        // Map incoming settings to Supabase format
        const supabaseData = {
          guild_id: guildId,
          recruit_channel_id: incomingSettings.recruit_channel || null,
          notification_role_id: incomingSettings.notification_role || null,
          default_title: incomingSettings.defaultTitle || "参加者募集",
          default_color: incomingSettings.defaultColor || "#00FFFF",
          update_channel_id: incomingSettings.update_channel || null,
          updated_at: new Date().toISOString()
        };
        
        console.log(`[finalize] Supabase data to save:`, supabaseData);
        
        // まず既存レコードがあるか確認
        const existingRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!existingRes.ok) {
          throw new Error(`Failed to check existing settings: ${existingRes.status} - ${await existingRes.text()}`);
        }
        
        const existingData = await existingRes.json();
        console.log(`[finalize] Existing guild settings:`, existingData);
        
        let supaRes;
        if (existingData && existingData.length > 0) {
          // 更新操作
          console.log(`[finalize] Updating existing guild settings for ${guildId}`);
          const patchBody = {
            updated_at: new Date().toISOString()
          };
          
          // Only include fields that are not null/undefined
          if (supabaseData.recruit_channel_id !== null) patchBody.recruit_channel_id = supabaseData.recruit_channel_id;
          if (supabaseData.notification_role_id !== null) patchBody.notification_role_id = supabaseData.notification_role_id;
          if (supabaseData.default_title) patchBody.default_title = supabaseData.default_title;
          if (supabaseData.default_color) patchBody.default_color = supabaseData.default_color;
          if (supabaseData.update_channel_id !== null) patchBody.update_channel_id = supabaseData.update_channel_id;

          supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
            method: 'PATCH',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(patchBody)
          });
        } else {
          // 新規作成
          console.log(`[finalize] Creating new guild settings for ${guildId}`);
          supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings', {
            method: 'POST',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(supabaseData)
          });
        }
        
        if (!supaRes.ok) {
          const errorText = await supaRes.text();
          console.error(`[finalize] Supabase operation failed:`);
          console.error(`[finalize] Status: ${supaRes.status}`);
          console.error(`[finalize] Status Text: ${supaRes.statusText}`);
          console.error(`[finalize] Response Body: ${errorText}`);
          throw new Error(`Supabase save failed: ${supaRes.status} - ${errorText}`);
        }
        
        console.log(`[finalize] Guild settings saved successfully for guild ${guildId}`);
        
        return new Response(JSON.stringify({ 
          ok: true, 
          message: "Settings saved successfully"
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[finalize] Guild settings finalize error:', error);
        console.error('[finalize] Error stack:', error.stack);
        return new Response(JSON.stringify({ 
          error: "Internal server error",
          details: error.message,
          timestamp: new Date().toISOString()
        }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }


    // Supabase接続テスト用API
    if (url.pathname === "/api/admin/supabase-test" && request.method === "GET") {
      try {
        console.log(`[supabase-test] Testing Supabase connection...`);
        
        // 1. 基本的な接続テスト
        const testRes = await fetch(env.SUPABASE_URL + '/rest/v1/', {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
          },
        });
        
        console.log(`[supabase-test] Basic connection: ${testRes.status}`);
        
        // 2. テーブル存在確認とサンプルデータ取得
        let tableExists = false;
        let tableStructure = null;
        let sampleData = null;
        try {
          const tableRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings?limit=1', {
            method: 'GET',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
          });
          
          if (tableRes.ok) {
            tableExists = true;
            const data = await tableRes.json();
            sampleData = data;
            if (Array.isArray(data) && data.length > 0) {
              tableStructure = `Columns: ${Object.keys(data[0]).join(', ')}`;
            } else {
              tableStructure = "Table exists but no data found";
            }
          } else {
            const errorText = await tableRes.text();
            tableStructure = `Table access failed: ${tableRes.status} - ${errorText}`;
          }
        } catch (tableError) {
          tableStructure = `Table check error: ${tableError.message}`;
        }
        
        // 3. 環境変数確認
        const envCheck = {
          supabaseUrlExists: !!env.SUPABASE_URL,
          supabaseKeyExists: !!env.SUPABASE_SERVICE_ROLE_KEY,
          supabaseUrlFormat: env.SUPABASE_URL ? env.SUPABASE_URL.includes('supabase') : false
        };
        
        return new Response(JSON.stringify({
          timestamp: new Date().toISOString(),
          basicConnection: testRes.ok ? 'Success' : `Failed: ${testRes.status}`,
          tableExists,
          tableStructure,
          sampleData,
          environmentVariables: envCheck,
          recommendation: !tableExists 
            ? "Run the SQL script to create guild_settings table"
            : "Supabase setup appears correct"
        }), {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } catch (error) {
        console.error('[supabase-test] Test error:', error);
        return new Response(JSON.stringify({
          error: "Supabase test failed",
          details: error.message,
          timestamp: new Date().toISOString()
        }), {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // データ状況確認用API
    if (url.pathname === "/api/admin/data-status" && request.method === "GET") {
      try {
        // KVから全ギルド設定を取得
        const kvList = await env.RECRUIT_KV.list({ prefix: 'guild_settings:' });
        const kvCount = kvList.keys.length;
        
        // Supabaseから全ギルド設定を取得
        const supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings?select=count', {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
            'Prefer': 'count=exact'
          },
        });
        
        let supabaseCount = 0;
        if (supaRes.ok) {
          const countHeader = supaRes.headers.get('content-range');
          if (countHeader) {
            const match = countHeader.match(/\/(\d+)$/);
            if (match) {
              supabaseCount = parseInt(match[1], 10);
            }
          }
        }
        
        return new Response(JSON.stringify({ 
          kv_guild_settings_count: kvCount,
          supabase_guild_settings_count: supabaseCount,
          data_migration_needed: kvCount > supabaseCount
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } catch (error) {
        console.error('Data status check error:', error);
        return new Response(JSON.stringify({ error: "Status check failed" }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // データマイグレーション用API（KV → Supabase）
    if (url.pathname === "/api/admin/migrate-guild-settings" && request.method === "POST") {
      try {
        // オプション: ?delete_kv=true を付けると、移行成功したKVキーを削除します
        const deleteKV = url.searchParams.get('delete_kv') === 'true';

        // KVから全ギルド設定を取得
        const list = await env.RECRUIT_KV.list({ prefix: 'guild_settings:' });
        const migrationResults = [];

        for (const entry of list.keys) {
          let guildId = entry.name.replace('guild_settings:', '');
          try {
            const kvData = await env.RECRUIT_KV.get(entry.name);
            if (kvData) {
              const settings = JSON.parse(kvData);

              // Supabase形式に変換
              const supabaseData = {
                guild_id: guildId,
                recruit_channel_id: settings.recruit_channel || settings.recruitmentChannelId,
                notification_role_id: settings.notification_role || settings.recruitmentNotificationRoleId,
                default_title: settings.defaultTitle || settings.defaultRecruitTitle || "参加者募集",
                default_color: settings.defaultColor || settings.defaultRecruitColor || "#00FFFF",
                update_channel_id: settings.update_channel || settings.updateNotificationChannelId
              };

              // Supabaseにupsert（resolution=merge-duplicates で upsert 相当）
              const supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings', {
                method: 'POST',
                headers: {
                  'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
                  'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
                  'Content-Type': 'application/json',
                  'Prefer': 'resolution=merge-duplicates'
                },
                body: JSON.stringify(supabaseData)
              });

              if (supaRes.ok) {
                migrationResults.push({ guildId, status: 'success' });
                console.log(`Migrated guild settings for ${guildId}`);

                // 成功した場合はオプションでKVを削除
                if (deleteKV) {
                  try {
                    await env.RECRUIT_KV.delete(entry.name);
                    console.log(`Deleted KV key ${entry.name} after migration`);
                    migrationResults[migrationResults.length - 1].kv_deleted = true;
                  } catch (delErr) {
                    console.warn(`Failed to delete KV key ${entry.name}: ${delErr.message}`);
                    migrationResults[migrationResults.length - 1].kv_deleted = false;
                    migrationResults[migrationResults.length - 1].kv_delete_error = delErr.message;
                  }
                }
              } else {
                migrationResults.push({ guildId, status: 'failed', error: supaRes.status });
                console.error(`Failed to migrate guild ${guildId}: ${supaRes.status}`);
              }
            }
          } catch (entryError) {
            console.error(`Error processing entry ${entry.name}:`, entryError);
            migrationResults.push({ guildId: entry.name, status: 'error', error: entryError.message });
          }
        }

        return new Response(JSON.stringify({ 
          ok: true, 
          message: `Migration completed. Processed ${migrationResults.length} guilds.`,
          delete_kv: deleteKV,
          results: migrationResults 
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } catch (error) {
        console.error('Migration error:', error);
        return new Response(JSON.stringify({ error: "Migration failed" }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // ギルド設定取得API（Supabaseメイン）
    if (url.pathname.startsWith("/api/guild-settings/") && request.method === "GET") {
      try {
        const guildId = url.pathname.split("/api/guild-settings/")[1];
        
        if (!guildId) {
          return new Response(JSON.stringify({ error: "Guild ID required" }), { 
            status: 400, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
        
        // Supabaseから設定を取得
        const supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
          method: 'GET',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (!supaRes.ok) {
          throw new Error(`Supabase fetch failed: ${supaRes.status}`);
        }
        
        const data = await supaRes.json();
        
        if (!Array.isArray(data) || data.length === 0) {
          // Supabaseにデータがない場合、KVフォールバックを試行
          console.log(`[guild-settings] No Supabase data found for guild ${guildId}, checking KV fallback`);
          
          try {
            // まず永続設定を確認
            let kvSettingsRaw = await env.RECRUIT_KV.get(`guild_settings:${guildId}`);
            console.log(`[guild-settings] KV permanent settings raw:`, kvSettingsRaw);
            
            if (!kvSettingsRaw) {
              // 永続設定がない場合はセッション設定を確認
              kvSettingsRaw = await env.RECRUIT_KV.get(`guild_session:${guildId}`);
              console.log(`[guild-settings] KV session settings raw:`, kvSettingsRaw);
            }
            
            if (kvSettingsRaw) {
              const kvSettings = JSON.parse(kvSettingsRaw);
              console.log(`[guild-settings] Found KV fallback settings:`, kvSettings);
              
              // KV形式からフロントエンド形式に変換
              const settings = {
                recruit_channel: kvSettings.recruit_channel || kvSettings.recruitmentChannelId,
                notification_role: kvSettings.notification_role || kvSettings.recruitmentNotificationRoleId,
                defaultTitle: kvSettings.defaultTitle || kvSettings.defaultRecruitTitle || "参加者募集",
                defaultColor: kvSettings.defaultColor || kvSettings.defaultRecruitColor || "#00FFFF",
                update_channel: kvSettings.update_channel || kvSettings.updateNotificationChannelId
              };
              
              console.log(`[guild-settings] Converted KV settings:`, settings);
              
              return new Response(JSON.stringify(settings), { 
                status: 200, 
                headers: { ...corsHeaders, "Content-Type": "application/json" }
              });
            } else {
              console.log(`[guild-settings] No KV data found for guild ${guildId}`);
            }
          } catch (kvError) {
            console.log(`[guild-settings] KV fallback failed:`, kvError);
          }
          
          // 設定が見つからない場合はデフォルト値を返す
          const defaultSettings = {
            recruit_channel: null,
            notification_role: null,
            defaultTitle: "参加者募集",
            defaultColor: "#00FFFF",
            update_channel: null
          };
          
          return new Response(JSON.stringify(defaultSettings), { 
            status: 200, 
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
        
        // Supabaseのデータ形式をフロントエンド形式に変換
        const settings = {
          recruit_channel: data[0].recruit_channel_id,
          notification_role: data[0].notification_role_id,
          defaultTitle: data[0].default_title || "参加者募集",
          defaultColor: data[0].default_color || "#00FFFF",
          update_channel: data[0].update_channel_id
        };
        
        return new Response(JSON.stringify(settings), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      } catch (error) {
        console.error('Guild settings fetch error:', error);
        
        // エラー時はデフォルト値を返す
        const defaultSettings = {
          recruit_channel: null,
          notification_role: null,
          defaultTitle: "参加者募集", 
          defaultColor: "#00FFFF",
          update_channel: null
        };
        
        return new Response(JSON.stringify(defaultSettings), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // Supabase直接テスト用API（一時的）
    if (url.pathname === "/api/test/supabase-direct" && request.method === "GET") {
      try {
        const guildId = "1414530004657766422";
        
        console.log(`[test] Direct Supabase test - guildId: ${guildId}`);
        
        // テストデータでUPDATE
        const updateData = {
          recruit_channel_id: "get_test_channel_789",
          notification_role_id: "get_test_role_987",
          updated_at: new Date().toISOString()
        };
        
        const supaRes = await fetch(env.SUPABASE_URL + `/rest/v1/guild_settings?guild_id=eq.${guildId}`, {
          method: 'PATCH',
          headers: {
            'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
            'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(updateData)
        });
        
        console.log(`[test] Update response status: ${supaRes.status}`);
        
        if (!supaRes.ok) {
          const errorText = await supaRes.text();
          console.error(`[test] Update failed: ${errorText}`);
          return new Response(JSON.stringify({
            error: "Supabase update failed",
            status: supaRes.status,
            statusText: supaRes.statusText,
            response: errorText,
            requestData: updateData
          }), {
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
        
        const result = await supaRes.json();
        console.log(`[test] Update success:`, result);
        
        return new Response(JSON.stringify({
          success: true,
          result,
          testData: updateData
        }), {
          status: 200,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('[test] Direct Supabase test error:', error);
        return new Response(JSON.stringify({
          error: "Test failed",
          details: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // ギルド数を更新するエンドポイント（Discord botから呼ばれる）
    if (url.pathname === '/api/guild-count-update' && request.method === 'POST') {
      try {
        const data = await request.json();
        const { count, timestamp, bot_id, event } = data;
        
        console.log(`[guild-count-update] Received update: count=${count}, bot_id=${bot_id}, event=${event || 'scheduled'}`);
        
        // KVにギルド数を保存
        await env.RECRUIT_KV.put('guild_count', JSON.stringify({
          count,
          timestamp,
          bot_id,
          event: event || 'scheduled',
          updated_at: new Date().toISOString()
        }));
        
        console.log(`[guild-count-update] Successfully stored guild count: ${count}`);
        
        return new Response(JSON.stringify({ 
          success: true,
          count,
          timestamp
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('Guild count update error:', error);
        return new Response(JSON.stringify({ error: 'Internal server error' }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // ギルド数を取得するエンドポイント
    if (url.pathname === '/api/guild-count' && request.method === 'GET') {
      try {
        console.log('[guild-count] Starting guild count fetch...');
        
        // まずKVからDiscord botが送信したリアルタイムギルド数を取得
        let realtimeCount = 0;
        let realtimeData = null;
        try {
          const kvGuildCount = await env.RECRUIT_KV.get('guild_count');
          if (kvGuildCount) {
            realtimeData = JSON.parse(kvGuildCount);
            realtimeCount = realtimeData.count || 0;
            console.log(`[guild-count] Realtime count from bot: ${realtimeCount} (updated: ${realtimeData.updated_at})`);
          }
        } catch (kvError) {
          console.log(`[guild-count] KV realtime data error: ${kvError.message}`);
        }
        
        // Supabaseのguild_settingsテーブルからユニークなギルド数を取得（バックアップ）
        let supabaseCount = 0;
        try {
          const supaRes = await fetch(env.SUPABASE_URL + '/rest/v1/guild_settings?select=guild_id', {
            method: 'GET',
            headers: {
              'apikey': env.SUPABASE_SERVICE_ROLE_KEY,
              'Authorization': `Bearer ${env.SUPABASE_SERVICE_ROLE_KEY}`,
              'Content-Type': 'application/json',
            },
          });
          
          if (supaRes.ok) {
            const data = await supaRes.json();
            if (Array.isArray(data)) {
              // ユニークなguild_idの数をカウント
              const uniqueGuilds = new Set(data.map(item => item.guild_id));
              supabaseCount = uniqueGuilds.size;
              console.log(`[guild-count] Supabase guild_settings count: ${supabaseCount}`);
            }
          } else {
            console.log(`[guild-count] Supabase guild_settings fetch failed: ${supaRes.status}`);
          }
        } catch (supaError) {
          console.log(`[guild-count] Supabase error: ${supaError.message}`);
        }
        
        // KVからもギルド設定数を取得
        let kvSettingsCount = 0;
        try {
          const kvList = await env.RECRUIT_KV.list({ prefix: 'guild_settings:' });
          kvSettingsCount = kvList.keys.length;
          console.log(`[guild-count] KV guild_settings count: ${kvSettingsCount}`);
        } catch (kvError) {
          console.log(`[guild-count] KV settings error: ${kvError.message}`);
        }
        
        // リアルタイムデータがある場合はそれを優先、なければ最大値を使用
        let finalCount = realtimeCount;
        let source = 'realtime';
        
        if (realtimeCount === 0) {
          finalCount = Math.max(supabaseCount, kvSettingsCount);
          source = supabaseCount >= kvSettingsCount ? 'supabase' : 'kv';
        }
        
        console.log(`[guild-count] Final count: ${finalCount} (source: ${source})`);
        
        return new Response(JSON.stringify({ 
          count: finalCount,
          source,
          realtimeCount,
          supabaseCount,
          kvSettingsCount,
          realtimeData
        }), { 
          status: 200, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
        
      } catch (error) {
        console.error('Guild count fetch error:', error);
        return new Response(JSON.stringify({ error: 'Internal server error', count: 0 }), { 
          status: 500, 
          headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
    }

    // すべてのルートにマッチしなかった場合の404レスポンス
    return new Response("Not Found", { 
      status: 404, 
      headers: corsHeaders 
    });
  }
}