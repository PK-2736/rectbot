# Clean GitHub Actions workflow for Supabase → Cloudflare R2 backup
# Runs on a self-hosted runner and reads credentials from repository Secrets.

name: Backup Supabase to Cloudflare R2

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 18 * * *' # JST 03:00

jobs:
  backup:
    name: Supabase → R2 Backup
    runs-on: ubuntu-latest
    env:
      SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
      SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
      R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Copy and run backup script on OCI via SSH
        env:
          OCI_SSH_KEY: ${{ secrets.OCI_SSH_KEY }}
          OCI_HOST: ${{ secrets.OCI_HOST }}
          OCI_USER: ${{ secrets.OCI_USER }}
          SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          set -euo pipefail
          if [ -z "${OCI_SSH_KEY}" ]; then
            echo "ERROR: OCI_SSH_KEY is not set" >&2
            exit 1
          fi
          if [ -z "${OCI_HOST}" ]; then
            echo "ERROR: OCI_HOST is not set" >&2
            exit 1
          fi
          if [ -z "${OCI_USER}" ]; then
            echo "ERROR: OCI_USER is not set" >&2
            exit 1
          fi

          # Write private key to file and set proper permissions.
          # Support two formats for OCI_SSH_KEY:
          # - Raw PEM (contains "-----BEGIN")
          # - Base64-encoded single-line string
          mkdir -p ~/.ssh
          if printf '%s' "$OCI_SSH_KEY" | grep -q -- "-----BEGIN"; then
            # Already a PEM; strip CRLF just in case and write
            printf '%s' "$OCI_SSH_KEY" | sed 's/\r$//' > ~/.ssh/id_ed25519
          else
            # Assume base64; strip CRLF then decode
            printf '%s' "$OCI_SSH_KEY" | tr -d '\r' | base64 -d > ~/.ssh/id_ed25519
          fi
          chmod 600 ~/.ssh/id_ed25519

          # Add host to known_hosts to avoid interactive prompt
          ssh-keyscan -H ${OCI_HOST} >> ~/.ssh/known_hosts 2>/dev/null || true

          # Show a short fingerprint of the private key's public counterpart (for debugging only)
          ssh-keygen -y -f ~/.ssh/id_ed25519 | ssh-keygen -lf - || true

          # Quick non-interactive connection test to surface auth errors early
          set +e
          ssh -i ~/.ssh/id_ed25519 -o BatchMode=yes -o StrictHostKeyChecking=no ${OCI_USER}@${OCI_HOST} 'echo SSH-OK' >/tmp/ssh_test_output 2>&1
          SSH_TEST_EXIT=$?
          set -e
          if [ ${SSH_TEST_EXIT} -ne 0 ]; then
            echo "ERROR: SSH test connection failed (exit=${SSH_TEST_EXIT}). Output:" >&2
            sed -n '1,200p' /tmp/ssh_test_output || true
            exit ${SSH_TEST_EXIT}
          fi

          # Copy the backup script to remote using the decoded key
          scp -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no ./backup_supabase_to_r2.sh ${OCI_USER}@${OCI_HOST}:/tmp/backup_supabase_to_r2.sh

          # Execute the script remotely with environment variables exported for the session
          ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no ${OCI_USER}@${OCI_HOST} <<'REMOTE'
            set -euo pipefail
            export SUPABASE_PROJECT_REF='${SUPABASE_PROJECT_REF}'
            export SUPABASE_DB_PASSWORD='${SUPABASE_DB_PASSWORD}'
            export R2_ACCOUNT_ID='${R2_ACCOUNT_ID}'
            export R2_ACCESS_KEY_ID='${R2_ACCESS_KEY_ID}'
            export R2_SECRET_ACCESS_KEY='${R2_SECRET_ACCESS_KEY}'
            export R2_BUCKET_NAME='${R2_BUCKET_NAME}'
            export DISCORD_WEBHOOK_URL='${DISCORD_WEBHOOK_URL}'
            chmod +x /tmp/backup_supabase_to_r2.sh
            /tmp/backup_supabase_to_r2.sh
          REMOTE

      - name: Make backup script executable
        run: chmod +x ./backup_supabase_to_r2.sh

      - name: Run backup script
        run: ./backup_supabase_to_r2.sh


